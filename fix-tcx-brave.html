<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TCX Workout Fixer (Brave Compatible)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: 50px auto; padding: 20px; background: #f5f5f5; }
    .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    h1 { color: #333; }
    .section { margin: 25px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; background: #fafafa; }
    label { display: block; margin: 10px 0 5px; font-weight: bold; color: #555; }
    input { padding: 8px; margin: 5px 0; width: 100%; max-width: 300px; border: 1px solid #ccc; border-radius: 4px; }
    button { padding: 10px 20px; margin: 5px 5px 5px 0; background: #0078d4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
    button:hover { background: #005a9e; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    #dropZone { border: 2px dashed #0078d4; padding: 40px; text-align: center; border-radius: 5px; background: #f0f7ff; margin: 20px 0; cursor: pointer; transition: background 0.2s; }
    #dropZone.dragover { background: #e8f4ff; border-color: #00a4ef; }
    #dropZone.dragging { background: #cce5ff; border-color: #0078d4; font-weight: bold; }
    #log { background: #333; color: #0f0; padding: 15px; border-radius: 4px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
    .status { margin: 10px 0; padding: 10px; border-radius: 4px; }
    .info { background: #e3f2fd; color: #1565c0; padding: 10px; border-radius: 4px; margin: 10px 0; }
    .warning { background: #fff3e0; color: #e65100; }
    .success { background: #e8f5e9; color: #2e7d32; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üèÉ TCX Workout Fixer (Compatible Brave)</h1>
    <div class="info">
      <strong>Mode Drag & Drop :</strong> Glissez vos fichiers .tcx ou dossier SRC ici pour traiter les workouts.
    </div>

    <div class="section">
      <h3>‚öôÔ∏è Configuration</h3>
      <label>Poids (kg) :</label>
      <input id="weightInput" type="number" value="70" min="30" max="200" step="1">
      
      <label>Pas / km :</label>
      <input id="stepsPerKmInput" type="number" value="1250" min="500" max="2000" step="50">
    </div>

    <div class="section">
      <h3>üìÅ Zone de d√©p√¥t</h3>
      <div id="dropZone">
        <p style="font-size: 16px; margin: 0;">
          üìÇ Glissez-d√©posez ici vos fichiers .tcx<br>
          <small style="color: #666; font-size: 12px;">ou un dossier contenant des fichiers .tcx</small>
        </p>
      </div>
      <button id="zipBtn" disabled>‚¨áÔ∏è T√©l√©charger ZIP</button>
    </div>

    <div class="section">
      <h3>üìä Logs</h3>
      <div id="log"></div>
    </div>
  </div>

  <script>
    const logEl = document.getElementById('log');
    const dropZone = document.getElementById('dropZone');
    const zipBtn = document.getElementById('zipBtn');
    const weightInput = document.getElementById('weightInput');
    const stepsPerKmInput = document.getElementById('stepsPerKmInput');

    let processedFiles = [];

    function log(...args) {
      const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
      const now = new Date().toLocaleTimeString();
      logEl.innerHTML += `[${now}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Drag and drop
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      dropZone.classList.add('dragging');

      const items = e.dataTransfer.items;
      if (!items) {
        log('‚ùå Erreur: Aucun fichier d√©tect√©.');
        dropZone.classList.remove('dragging');
        return;
      }

      processedFiles = [];
      let filesCount = 0;

      try {
        for (const item of items) {
          const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
          if (!entry) continue;

          if (entry.isDirectory) {
            log('üìÇ Lecture du dossier:', entry.name);
            await readDirectory(entry);
          } else if (entry.isFile) {
            const file = await new Promise((resolve, reject) => {
              entry.file(resolve, reject);
            });
            if (file.name.toLowerCase().endsWith('.tcx')) {
              filesCount++;
              await processFile(file);
            }
          }
        }

        if (filesCount === 0 && e.dataTransfer.files.length > 0) {
          for (const file of e.dataTransfer.files) {
            if (file.name.toLowerCase().endsWith('.tcx')) {
              filesCount++;
              await processFile(file);
            }
          }
        }

        if (processedFiles.length > 0) {
          log(`‚úÖ ${processedFiles.length} fichier(s) trait√©(s) avec succ√®s`);
          zipBtn.disabled = false;
        } else {
          log('‚ö†Ô∏è Aucun fichier .tcx trouv√©');
        }
      } catch (err) {
        log('‚ùå Erreur:', err.message);
      } finally {
        dropZone.classList.remove('dragging');
      }
    });

    async function readDirectory(dirEntry) {
      const reader = dirEntry.createReader();
      return new Promise((resolve) => {
        const readEntries = () => {
          reader.readEntries(async (entries) => {
            for (const entry of entries) {
              if (entry.isFile && entry.name.toLowerCase().endsWith('.tcx')) {
                const file = await new Promise((res, rej) => entry.file(res, rej));
                await processFile(file);
              } else if (entry.isDirectory) {
                await readDirectory(entry);
              }
            }
            if (entries.length === 0) resolve();
            else readEntries();
          });
        };
        readEntries();
      });
    }

    async function processFile(file) {
      log('üìÑ Traitement:', file.name);

      let s = await file.text();

      // Changer Sport="Other" en Sport="Running"
      s = s.replace(/(<Activity\b[^>]*\bSport=")([^"]*)(")/i, '$1Running$3');

      // Extraire max distance depuis les Trackpoints
      const tpRegex = /<Trackpoint\b[\s\S]*?<DistanceMeters>([\d.]+)<\/DistanceMeters>[\s\S]*?<\/Trackpoint>/gi;
      let m;
      let max = 0;
      while ((m = tpRegex.exec(s)) !== null) {
        const val = parseFloat(m[1]);
        if (!isNaN(val) && val > max) max = val;
      }

      // √âcrire max distance dans Lap
      if (max > 0) {
        const lapDistRegex = /(<Lap\b[^>]*>[\s\S]*?<DistanceMeters>)([\d.]+)(<\/DistanceMeters>[\s\S]*?<\/Lap>)/i;
        if (lapDistRegex.test(s)) {
          s = s.replace(lapDistRegex, function(_, a, _old, b) { return a + String(max) + b; });
        } else {
          s = s.replace(/(<Lap\b[^>]*>)/i, function(m0) { return m0 + '\n      <DistanceMeters>' + String(max) + '</DistanceMeters>'; });
        }
      }

      // Calculer pas depuis distance
      const stepsPerKmVal = parseFloat(stepsPerKmInput.value) || 1250;
      let estimatedSteps = 0;
      if (max > 0) {
        estimatedSteps = Math.round((max / 1000) * stepsPerKmVal);
      }

      const cadenceRegex = /<Cadence>([\d.]+)<\/Cadence>/gi;
      let c;
      const cadences = [];
      while ((c = cadenceRegex.exec(s)) !== null) {
        cadences.push(parseFloat(c[1]));
      }
      const avgCadence = cadences.length ? (cadences.reduce((a, b) => a + b, 0) / cadences.length) : 0;

      processedFiles.push({
        name: file.name,
        content: s,
        estimatedSteps,
        avgCadence: Math.round(avgCadence * 100) / 100,
        distance: max
      });

      log(`  ‚úì ${file.name}: ${estimatedSteps} pas, distance: ${max}m`);
    }

    // G√©n√©rer ZIP
    zipBtn.addEventListener('click', async () => {
      if (processedFiles.length === 0) {
        log('‚ùå Aucun fichier √† t√©l√©charger');
        return;
      }

      zipBtn.disabled = true;
      try {
        log('üì¶ Cr√©ation du ZIP...');
        const zip = new JSZip();

        processedFiles.forEach(f => {
          zip.file(f.name, f.content);
        });

        // Cr√©er summary.txt
        let txt = '';
        processedFiles.forEach(e => {
          txt += `${e.name}: ${e.estimatedSteps} pas\n`;
        });
        zip.file('summary.txt', txt);

        // G√©n√©rer et t√©l√©charger
        const blob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'fixed-tcx-files.zip';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);

        log('‚úÖ ZIP pr√™t ‚Äî t√©l√©chargement d√©clench√©');
      } catch (e) {
        log('‚ùå Erreur ZIP:', e.message);
      } finally {
        zipBtn.disabled = false;
      }
    });

    log('‚úÖ App pr√™te. Glissez vos fichiers .tcx ici.');
  </script>
</body>
</html>
